# BUILD.gn  -  Linux host 交叉编译 Windows MinGW-w64 工具链
# 用法示例：
#   gn gen out/cross --args='
#       is_debug=false
#       target_cpu="x64"
#       target_os="win"
#       mingw_toolchain="//:mingw"

# 0. 基本参数
declare_args() {
  host_ar = "ar"
  host_cc = "gcc"
  host_cxx = "g++"
  host_link = "g++"

  target_ar = "x86_64-w64-mingw32-ar"
  target_cc = "x86_64-w64-mingw32-gcc"
  target_cxx = "x86_64-w64-mingw32-g++"
  target_link = "x86_64-w64-mingw32-g++"

  cc_wrapper = ""      # 如需 ccache 可填 ccache
}

template("gcc_like_toolchain") {
  toolchain(target_name) {
    ar = invoker.ar
    cc = invoker.cc
    cxx = invoker.cxx
    link = invoker.link
    lib_switch = "-l"
    lib_dir_switch = "-L"

    tool("cc") {
      depfile = "{{output}}.d"
      command = "$cc_wrapper $cc -MD -MF $depfile {{defines}} {{include_dirs}} {{cflags}} {{cflags_c}} -c {{source}} -o {{output}}"
      depsformat = "gcc"
      outputs =
          [ "{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o" ]
      description = "compile {{source}}"
    }

    tool("cxx") {
      depfile = "{{output}}.d"
      command = "$cc_wrapper $cxx -MD -MF $depfile {{defines}} {{include_dirs}} {{cflags}} {{cflags_cc}} -c {{source}} -o {{output}}"
      depsformat = "gcc"
      outputs =
          [ "{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o" ]
      description = "compile {{source}}"
    }

    tool("objc") {
      depfile = "{{output}}.d"
      command = "$cc_wrapper $cc -MD -MF $depfile {{defines}} {{include_dirs}} {{framework_dirs}} {{cflags}} {{cflags_objc}} -c {{source}} -o {{output}}"
      depsformat = "gcc"
      outputs =
          [ "{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o" ]
      description = "compile {{source}}"
    }

    tool("objcxx") {
      depfile = "{{output}}.d"
      command = "$cc_wrapper $cxx -MD -MF $depfile {{defines}} {{include_dirs}} {{framework_dirs}} {{cflags}} {{cflags_objcc}} -c {{source}} -o {{output}}"
      depsformat = "gcc"
      outputs =
          [ "{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o" ]
      description = "compile {{source}}"
    }

    tool("asm") {
      depfile = "{{output}}.d"
      command = "$cc_wrapper $cc -MD -MF $depfile {{defines}} {{include_dirs}} {{asmflags}} -c {{source}} -o {{output}}"
      depsformat = "gcc"
      outputs =
          [ "{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o" ]
      description = "assemble {{source}}"
    }

    if (is_mac || is_ios) {
      not_needed([ "ar" ])  # We use libtool instead.
    }

    tool("alink") {
      if (is_mac || is_ios) {
        command = "libtool -static -o {{output}} -no_warning_for_no_symbols {{inputs}}"
      } else {
        rspfile = "{{output}}.rsp"
        rspfile_content = "{{inputs}}"
        rm_py = rebase_path("../rm.py")
        command = "python3 \"$rm_py\" \"{{output}}\" && $ar rcs {{output}} @$rspfile"
      }

      outputs =
          [ "{{root_out_dir}}/{{target_output_name}}{{output_extension}}" ]
      default_output_extension = ".a"
      output_prefix = "lib"
      description = "link {{output}}"
      # if (0 <= link_pool_depth) {
      #   pool = ":link_pool($default_toolchain)"
      # }
    }

    tool("solink") {
      soname = "{{target_output_name}}{{output_extension}}"

      rpath = "-Wl,-soname,$soname"
      if (is_mac || is_ios) {
        rpath = "-Wl,-install_name,@rpath/$soname"
      }

      rspfile = "{{output}}.rsp"
      rspfile_content = "{{inputs}}"

      # --start-group/--end-group let us link multiple .a {{inputs}}
      # without worrying about their relative order on the link line.
      #
      # This is mostly important for traditional linkers like GNU ld and Gold.
      # The Mac/iOS linker neither needs nor accepts these flags.
      # LLD doesn't need these flags, but accepts and ignores them.
      _start_group = "-Wl,--start-group"
      _end_group = "-Wl,--end-group"
      if (is_mac || is_ios || is_fuchsia) {
        _start_group = ""
        _end_group = ""
      }

      command = "$link -shared {{ldflags}} $_start_group @$rspfile {{frameworks}} {{solibs}} $_end_group {{libs}} $rpath -o {{output}}"
      outputs = [ "{{root_out_dir}}/$soname" ]
      output_prefix = "lib"
      if (is_mac || is_ios) {
        default_output_extension = ".dylib"
      } else {
        default_output_extension = ".so"
      }
      description = "link {{output}}"
      # if (0 <= link_pool_depth) {
      #   pool = ":link_pool($default_toolchain)"
      # }
    }

    tool("link") {
      exe_name = "{{root_out_dir}}/{{target_output_name}}{{output_extension}}"
      rspfile = "$exe_name.rsp"
      rspfile_content = "{{inputs}}"

      # --start-group/--end-group let us link multiple .a {{inputs}}
      # without worrying about their relative order on the link line.
      #
      # This is mostly important for traditional linkers like GNU ld and Gold.
      # The Mac/iOS linker neither needs nor accepts these flags.
      # LLD doesn't need these flags, but accepts and ignores them.
      _start_group = "-Wl,--start-group"
      _end_group = "-Wl,--end-group"
      if (is_mac || is_ios || is_fuchsia) {
        _start_group = ""
        _end_group = ""
      }
      command = "$link {{ldflags}} $_start_group @$rspfile {{frameworks}} {{solibs}} $_end_group {{libs}} -o $exe_name"

      outputs = [ "$exe_name" ]
      description = "link {{output}}"
      # if (0 <= link_pool_depth) {
      #   pool = ":link_pool($default_toolchain)"
      # }
    }

    tool("stamp") {
      command = "touch {{output}}"
      description = "stamp {{output}}"
    }

    tool("copy") {
      cp_py = rebase_path("../cp.py")
      command = "python3 \"$cp_py\" {{source}} {{output}}"
      description = "copy {{source}} {{output}}"
    }

    tool("copy_bundle_data") {
      cp_py = rebase_path("../cp.py")
      command = "python3 \"$cp_py\" {{source}} {{output}}"
      description = "copy_bundle_data {{source}} {{output}}"
    }

    # We don't currently have any xcasset files so make this a NOP
    tool("compile_xcassets") {
      command = "true"
      description = "compile_xcassets {{output}}"
    }

    toolchain_args = {
      current_cpu = invoker.cpu
      current_os = invoker.os
    }
  }
}

# 1. 工具链模板
template("mingw_toolchain") {
  toolchain(target_name) {
    link  = invoker.link
    ar    = invoker.ar
    cc    = invoker.cc
    cxx   = invoker.cxx

    toolchain_args = {
      current_cpu = invoker.cpu
      current_os = "win"
    }

    lib_switch = "-l"
    lib_dir_switch = "-L"

    tool("cc") {
      depfile = "{{output}}.d"
      command = "$cc_wrapper $cc -MD -MF $depfile {{defines}} {{include_dirs}} {{cflags}} {{cflags_c}} -c {{source}} -o {{output}}"
      depsformat = "gcc"
      outputs = [ "{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o" ]
      description = "CC  {{source}}"
    }

    tool("cxx") {
      depfile = "{{output}}.d"
      command = "$cc_wrapper $cxx -MD -MF $depfile {{defines}} {{include_dirs}} {{cflags}} {{cflags_cc}} -c {{source}} -o {{output}}"
      depsformat = "gcc"
      outputs = [ "{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o" ]
      description = "CXX {{source}}"
    }

    tool("asm") {
      command = "$cc_wrapper $cc -c {{asmflags}} {{source}} -o {{output}}"
      outputs = [ "{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o" ]
      description = "ASM {{source}}"
    }

    tool("alink") {
      rspfile = "{{output}}.rsp"
      rspfile_content = "{{inputs}}"
      command = "rm -f {{output}} && $ar rcs {{output}} @$rspfile"
      outputs = [ "{{root_out_dir}}/{{target_output_name}}{{output_extension}}" ]
      default_output_extension = ".a"
      output_prefix = "lib"
      description = "AR  {{output}}"
    }

    tool("solink") {
      soname = "{{target_output_name}}{{output_extension}}"
      rspfile = "{{output}}.rsp"
      rspfile_content = "{{inputs}}"
      command = "$link -shared {{ldflags}} -Wl,--out-implib,{{root_out_dir}}/{{target_output_name}}.dll.a -Wl,--soname,$soname @$rspfile {{libs}} -o {{output}}"
      outputs = [ "{{root_out_dir}}/$soname" ]
      default_output_extension = ".dll"
      output_prefix = ""
      description = "DLL {{output}}"
    }

    tool("link") {
      exename = "{{root_out_dir}}/{{target_output_name}}{{output_extension}}"
      rspfile = "$exename.rsp"
      rspfile_content = "{{inputs}}"
      command = "$link {{ldflags}} @$rspfile {{libs}} -o $exename"
      outputs = [ "$exename" ]
      default_output_extension = ".exe"
      description = "EXE $exename"
    }

    tool("stamp")   { command = "touch {{output}}" }
    tool("copy")    {
      cp_py = rebase_path("//bin/cp.py")   # Skia 自带
      command = "python3 \"$cp_py\" {{source}} {{output}}"
    }
  }
}

# 2. 实例化工具链
gcc_like_toolchain("mingw") {
  cpu = target_cpu   # x64 / x86 / arm64 均可
  ar = target_ar
  cc = target_cc
  cxx = target_cxx
  link = target_link
  os = target_os
}

gcc_like_toolchain("mingw_host") {
  cpu = host_cpu     # x64 / x86 / arm64 均可
  ar = host_ar
  cc = host_cc
  cxx = host_cxx
  link = host_link
  os = host_os
}
